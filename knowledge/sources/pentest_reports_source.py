#!/usr/bin/env python3
"""
Penetration Test Reports Source - Integrazione report pubblici di pentest
"""
import requests
from bs4 import BeautifulSoup
import re
from typing import List, Dict, Optional
from datetime import datetime
from .base import DataSource, SourceResult

class PentestReportsSource(DataSource):
    """Source per penetration test reports pubblici"""
    
    SOURCES = {
        'cure53': {
            'base_url': 'https://cure53.de',
            'blog_url': 'https://cure53.de/#publications',
            'pattern': 'cure53'
        },
        'ncc_group': {
            'base_url': 'https://www.nccgroup.com',
            'blog_url': 'https://www.nccgroup.com/uk/about-us/newsroom-and-events/blogs/',
            'pattern': 'ncc group'
        },
        'trail_of_bits': {
            'base_url': 'https://www.trailofbits.com',
            'blog_url': 'https://blog.trailofbits.com',
            'pattern': 'trail of bits'
        }
    }
    
    def __init__(self, enabled: bool = True):
        super().__init__('pentest_reports', enabled)
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'KaliAI-PentestReports/1.0'
        })
    
    def fetch(self, max_reports: int = 20) -> List[SourceResult]:
        """
        Fetcha report di penetration test pubblici.
        """
        if not self.enabled:
            return []
        
        results = []
        
        try:
            # Cerca report da ogni fonte
            for source_name, source_info in self.SOURCES.items():
                try:
                    print(f"[Pentest Reports] Cercando report da {source_name}...")
                    source_results = self._fetch_from_source(source_name, source_info, max_reports // len(self.SOURCES))
                    results.extend(source_results)
                except Exception as e:
                    print(f"[Pentest Reports] Errore da {source_name}: {e}")
                    continue
            
            self.fetch_count += 1
            self.last_fetch = datetime.now()
            print(f"[Pentest Reports] ✅ Processati {len(results)} report")
            
        except Exception as e:
            self.error_count += 1
            print(f"[Pentest Reports] Errore fetch: {e}")
            import traceback
            traceback.print_exc()
        
        return results
    
    def _fetch_from_source(self, source_name: str, source_info: Dict, max_items: int) -> List[SourceResult]:
        """Fetcha report da una fonte specifica"""
        results = []
        
        try:
            # Per ora, creiamo template per report comuni
            # In produzione, si potrebbe fare scraping più sofisticato
            
            # Lista di report pubblici noti
            known_reports = {
                'cure53': [
                    'Signal Audit', 'Wire Audit', '1Password Audit',
                    'ProtonMail Audit', 'Tutanota Audit'
                ],
                'ncc_group': [
                    'OpenSSL Audit', 'Tor Browser Audit'
                ],
                'trail_of_bits': [
                    'Algorand Audit', 'Compound Protocol Audit'
                ]
            }
            
            reports = known_reports.get(source_name, [])
            
            for report_name in reports[:max_items]:
                try:
                    content = f"""
# Penetration Test Report: {report_name}

## Source
{source_info['base_url']}

## Report Information
Report: {report_name}
Company: {source_info['pattern'].title()}
Type: Public Security Audit

## Methodology
1. Reconnaissance and Information Gathering
2. Vulnerability Assessment
3. Exploitation Testing
4. Post-Exploitation Analysis
5. Reporting and Recommendations

## Key Findings
(To be populated from actual report content)

## Vulnerabilities Identified
- To be extracted from report

## Recommendations
- Security best practices
- Remediation steps
- Long-term improvements

## Lessons Learned
- Methodology insights
- Common vulnerabilities
- Testing techniques

## Notes
This is a template. In production, scrape actual report content from {source_info['blog_url']}
"""
                    
                    results.append(SourceResult(
                        title=f"{source_name.title()} - {report_name}",
                        content=content.strip(),
                        source_type='pentest_report',
                        source_name='pentest_reports',
                        url=source_info['blog_url'],
                        metadata={
                            'source': source_name,
                            'report_name': report_name,
                            'type': 'public_audit'
                        },
                        timestamp=datetime.now(),
                        relevance_score=0.9
                    ))
                    
                except Exception as e:
                    print(f"[Pentest Reports] Errore processando {report_name}: {e}")
                    continue
        
        except Exception as e:
            print(f"[Pentest Reports] Errore fetch da {source_name}: {e}")
        
        return results
    
    def get_source_info(self) -> Dict:
        """Info sul source"""
        return {
            'name': self.name,
            'type': 'pentest_report',
            'url': 'Multiple sources (Cure53, NCC Group, Trail of Bits)',
            'description': 'Public penetration test reports and security audits',
            'rate_limit': 'Respect robots.txt',
            'requires_auth': False
        }


