#!/usr/bin/env python3
"""
Exploit-DB Repository Source - Integrazione repository completo Exploit-DB
"""
import os
import csv
import subprocess
from pathlib import Path
from typing import List, Dict, Optional
from datetime import datetime
from .base import DataSource, SourceResult

class ExploitDBRepoSource(DataSource):
    """Source per Exploit-DB repository completo (GitHub)"""
    
    REPO_URL = 'https://github.com/offensive-security/exploitdb.git'
    REPO_NAME = 'exploitdb'
    
    def __init__(self, enabled: bool = True, repo_path: Optional[str] = None):
        super().__init__('exploitdb_repo', enabled)
        self.repo_path = repo_path or Path(__file__).parent.parent.parent / 'data' / 'exploitdb'
        self.repo_path = Path(self.repo_path)
    
    def fetch(self, update_repo: bool = True, max_exploits: Optional[int] = None):
        """
        Fetcha exploit dal repository Exploit-DB.
        
        Args:
            update_repo: Se True, aggiorna il repository con git pull
            max_exploits: Numero massimo di exploit da processare (None = tutti)
            
        Yields:
            SourceResult
        """
        if not self.enabled:
            return
        
        count = 0
        
        try:
            # Clona o aggiorna repository
            if not self.repo_path.exists() or update_repo:
                self._ensure_repo()
            
            if not self.repo_path.exists():
                print(f"[Exploit-DB Repo] Repository non trovato: {self.repo_path}")
                return
            
            # Leggi CSV con metadati
            csv_path = self.repo_path / 'files_exploits.csv'
            if not csv_path.exists():
                print(f"[Exploit-DB Repo] CSV non trovato: {csv_path}")
                return
            
            print(f"[Exploit-DB Repo] Leggendo CSV...")
            exploits_metadata = self._read_csv(csv_path)
            
            if max_exploits:
                # Prendi gli ultimi N exploit (i più recenti)
                if len(exploits_metadata) > max_exploits:
                    exploits_metadata = exploits_metadata[-max_exploits:]
            
            print(f"[Exploit-DB Repo] Processando {len(exploits_metadata)} exploit...")
            
            # Processa ogni exploit
            for exploit_info in exploits_metadata:
                try:
                    exploit_result = self._process_exploit(exploit_info)
                    if exploit_result:
                        yield exploit_result
                        count += 1
                except Exception as e:
                    print(f"[Exploit-DB Repo] Errore processando exploit {exploit_info.get('id')}: {e}")
                    continue
            
            self.fetch_count += 1
            self.last_fetch = datetime.now()
            print(f"[Exploit-DB Repo] ✅ Processati {count} exploit")
            
        except Exception as e:
            self.error_count += 1
            print(f"[Exploit-DB Repo] Errore fetch: {e}")
            import traceback
            traceback.print_exc()
    
    def _ensure_repo(self):
        """Assicura che il repository sia clonato/aggiornato"""
        import subprocess
        
        if self.repo_path.exists():
            # Repository esiste, fai pull
            try:
                print(f"[Exploit-DB Repo] Aggiornamento repository...")
                subprocess.run(
                    ['git', 'pull'],
                    cwd=self.repo_path,
                    check=True,
                    capture_output=True,
                    timeout=300
                )
                print(f"[Exploit-DB Repo] ✅ Repository aggiornato")
            except subprocess.TimeoutExpired:
                print(f"[Exploit-DB Repo] ⚠️ Timeout durante git pull")
            except subprocess.CalledProcessError as e:
                print(f"[Exploit-DB Repo] ⚠️ Errore git pull: {e}")
        else:
            # Clona repository
            try:
                print(f"[Exploit-DB Repo] Clonazione repository...")
                self.repo_path.parent.mkdir(parents=True, exist_ok=True)
                subprocess.run(
                    ['git', 'clone', self.REPO_URL, str(self.repo_path)],
                    check=True,
                    capture_output=True,
                    timeout=600
                )
                print(f"[Exploit-DB Repo] ✅ Repository clonato")
            except subprocess.TimeoutExpired:
                print(f"[Exploit-DB Repo] ⚠️ Timeout durante git clone")
            except subprocess.CalledProcessError as e:
                print(f"[Exploit-DB Repo] ⚠️ Errore git clone: {e}")
    
    def _read_csv(self, csv_path: Path) -> List[Dict]:
        """Legge CSV con metadati exploit"""
        exploits = []
        
        try:
            with open(csv_path, 'r', encoding='utf-8', errors='ignore') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    exploits.append(row)
        except Exception as e:
            print(f"[Exploit-DB Repo] Errore leggendo CSV: {e}")
        
        return exploits
    
    def _process_exploit(self, exploit_info: Dict) -> Optional[SourceResult]:
        """Processa un singolo exploit"""
        try:
            exploit_id = exploit_info.get('id', '')
            file_path = exploit_info.get('file', '')
            description = exploit_info.get('description', '')
            date_published = exploit_info.get('date_published', '')
            author = exploit_info.get('author', '')
            platform = exploit_info.get('platform', '')
            exploit_type = exploit_info.get('type', '')
            
            # Leggi contenuto file exploit
            exploit_file_path = self.repo_path / 'exploits' / file_path
            exploit_content = ''
            
            if exploit_file_path.exists():
                try:
                    exploit_content = exploit_file_path.read_text(encoding='utf-8', errors='ignore')
                except:
                    pass
            
            # Estrai informazioni dal codice
            code_info = self._extract_code_info(exploit_content)
            
            # Costruisci contenuto
            content = f"""
Exploit-DB Entry: {exploit_id}

DESCRIPTION:
{description}

PLATFORM: {platform}
TYPE: {exploit_type}
AUTHOR: {author}
DATE PUBLISHED: {date_published}

EXPLOIT FILE: {file_path}

CODE ANALYSIS:
{code_info['summary']}

KEY FUNCTIONS:
{chr(10).join(f"- {func}" for func in code_info['functions'][:10])}

VULNERABILITIES MENTIONED:
{chr(10).join(f"- {vuln}" for vuln in code_info['vulnerabilities'][:10])}

EXPLOIT CODE (first 1000 chars):
{exploit_content[:1000] if exploit_content else 'N/A'}
"""
            
            # Parse date
            timestamp = datetime.now()
            try:
                if date_published:
                    timestamp = datetime.strptime(date_published, '%Y-%m-%d')
            except:
                pass
            
            # Relevance basata su contenuto
            relevance = 0.9 if code_info['has_exploit_code'] else 0.7
            
            return SourceResult(
                title=f"Exploit-DB {exploit_id}: {description[:100]}",
                content=content.strip(),
                source_type='exploit',
                source_name='exploitdb_repo',
                url=f"https://www.exploit-db.com/exploits/{exploit_id}",
                metadata={
                    'exploit_id': exploit_id,
                    'platform': platform,
                    'type': exploit_type,
                    'author': author,
                    'date_published': date_published,
                    'file_path': file_path,
                    'has_code': code_info['has_exploit_code'],
                    'vulnerability_count': len(code_info['vulnerabilities'])
                },
                timestamp=timestamp,
                relevance_score=relevance
            )
            
        except Exception as e:
            print(f"[Exploit-DB Repo] Errore processando exploit: {e}")
            return None
    
    def _extract_code_info(self, code: str) -> Dict:
        """Estrae informazioni dal codice exploit"""
        info = {
            'summary': '',
            'functions': [],
            'vulnerabilities': [],
            'has_exploit_code': len(code) > 100
        }
        
        if not code:
            return info
        
        # Estrai funzioni (pattern comuni)
        import re
        
        # Funzioni Python
        python_funcs = re.findall(r'def\s+(\w+)', code)
        info['functions'].extend(python_funcs[:10])
        
        # Funzioni C
        c_funcs = re.findall(r'(\w+)\s*\([^)]*\)\s*\{', code)
        info['functions'].extend(c_funcs[:10])
        
        # CVE mentions
        cves = re.findall(r'CVE-\d{4}-\d+', code)
        info['vulnerabilities'].extend(cves)
        
        # Vulnerabilità comuni
        vuln_keywords = ['buffer overflow', 'sql injection', 'xss', 'rce', 'lfi', 'rfi', 'command injection']
        for keyword in vuln_keywords:
            if keyword.lower() in code.lower():
                info['vulnerabilities'].append(keyword)
        
        # Summary
        lines = code.split('\n')[:20]
        info['summary'] = '\n'.join(lines)
        
        return info
    
    def get_source_info(self) -> Dict:
        """Info sul source"""
        return {
            'name': self.name,
            'type': 'exploit_repository',
            'url': self.REPO_URL.replace('.git', ''),
            'description': 'Exploit-DB complete repository with exploit code',
            'rate_limit': None,
            'requires_auth': False,
            'repo_path': str(self.repo_path)
        }


