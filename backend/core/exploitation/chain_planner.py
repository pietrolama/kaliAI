#!/usr/bin/env python3
"""
Exploitation Chain Planner - Multi-Stage Attack Orchestration
â›“ï¸ Pianifica e orchestra attacchi multi-step verso obiettivi complessi.

FunzionalitÃ :
- Attack path planning basato su MITRE ATT&CK
- Chain execution con fallback
- Pivot point tracking
- Adaptive strategy on failure
"""

import os
import logging
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field
from enum import Enum

logger = logging.getLogger('ChainPlanner')

# ============================================================================
# MITRE ATT&CK PHASES
# ============================================================================

class AttackPhase(Enum):
    """Fasi MITRE ATT&CK"""
    RECONNAISSANCE = ("recon", "TA0043")
    RESOURCE_DEVELOPMENT = ("resource", "TA0042")
    INITIAL_ACCESS = ("initial", "TA0001")
    EXECUTION = ("exec", "TA0002")
    PERSISTENCE = ("persist", "TA0003")
    PRIVILEGE_ESCALATION = ("privesc", "TA0004")
    DEFENSE_EVASION = ("evasion", "TA0005")
    CREDENTIAL_ACCESS = ("creds", "TA0006")
    DISCOVERY = ("discovery", "TA0007")
    LATERAL_MOVEMENT = ("lateral", "TA0008")
    COLLECTION = ("collect", "TA0009")
    COMMAND_AND_CONTROL = ("c2", "TA0011")
    EXFILTRATION = ("exfil", "TA0010")
    IMPACT = ("impact", "TA0040")

class StepStatus(Enum):
    """Stato di un passo dell'attacco"""
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    SKIPPED = "skipped"
    BLOCKED = "blocked"

# ============================================================================
# DATA STRUCTURES
# ============================================================================

@dataclass
class AttackStep:
    """Singolo passo di un attacco"""
    id: str
    name: str
    phase: AttackPhase
    technique: str  # es: "T1190 - Exploit Public Application"
    command: str    # Comando da eseguire
    expected_output: str  # Pattern atteso nell'output
    alternatives: List[str] = field(default_factory=list)  # Comandi alternativi
    prerequisites: List[str] = field(default_factory=list)  # Step ID prerequisiti
    status: StepStatus = StepStatus.PENDING
    output: str = ""
    error: str = ""
    
    def mark_success(self, output: str):
        self.status = StepStatus.SUCCESS
        self.output = output
    
    def mark_failed(self, error: str):
        self.status = StepStatus.FAILED
        self.error = error

@dataclass
class AttackChain:
    """Catena completa di attacco"""
    chain_id: str
    name: str
    target: str
    goal: str  # Obiettivo finale (flag, DA, exfil)
    steps: List[AttackStep] = field(default_factory=list)
    current_step: int = 0
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())
    
    def get_current_step(self) -> Optional[AttackStep]:
        if 0 <= self.current_step < len(self.steps):
            return self.steps[self.current_step]
        return None
    
    def advance(self) -> bool:
        """Avanza al prossimo step. Returns False se chain completata."""
        self.current_step += 1
        return self.current_step < len(self.steps)
    
    def get_progress(self) -> Tuple[int, int]:
        """Returns (completed, total)"""
        completed = sum(1 for s in self.steps if s.status == StepStatus.SUCCESS)
        return (completed, len(self.steps))

@dataclass 
class Foothold:
    """Rappresenta un accesso ottenuto"""
    host: str
    access_type: str  # shell, ssh, rdp, etc.
    access_level: str  # user, root, SYSTEM
    credentials: Dict[str, str] = field(default_factory=dict)
    obtained_at: str = field(default_factory=lambda: datetime.now().isoformat())
    pivot_possible: bool = False

# ============================================================================
# ATTACK TEMPLATES
# ============================================================================

ATTACK_TEMPLATES: Dict[str, List[dict]] = {
    # Template per Linux SSH
    "linux_ssh_pentest": [
        {
            "name": "SSH Banner Grab",
            "phase": AttackPhase.RECONNAISSANCE,
            "technique": "T1046 - Network Service Discovery",
            "command": "nc -v {target} 22",
            "expected": "SSH-",
            "alternatives": ["nmap -sV -p22 {target}"]
        },
        {
            "name": "SSH Auth Methods",
            "phase": AttackPhase.DISCOVERY,
            "technique": "T1087 - Account Discovery",
            "command": "ssh -o PreferredAuthentications=none -o PubkeyAuthentication=no {target} 2>&1",
            "expected": "Permission denied",
            "alternatives": []
        },
        {
            "name": "Default Creds Test",
            "phase": AttackPhase.INITIAL_ACCESS,
            "technique": "T1078 - Valid Accounts",
            "command": "sshpass -p 'admin' ssh -o StrictHostKeyChecking=no admin@{target} whoami 2>&1",
            "expected": "admin",
            "alternatives": [
                "sshpass -p 'root' ssh -o StrictHostKeyChecking=no root@{target} whoami 2>&1",
                "sshpass -p 'password' ssh -o StrictHostKeyChecking=no admin@{target} whoami 2>&1"
            ]
        },
    ],
    
    # Template per Web App
    "web_app_pentest": [
        {
            "name": "HTTP Headers Recon",
            "phase": AttackPhase.RECONNAISSANCE,
            "technique": "T1592 - Gather Victim Host Info",
            "command": "curl -I http://{target}",
            "expected": "HTTP/",
            "alternatives": ["wget -S --spider http://{target}"]
        },
        {
            "name": "Technology Fingerprint",
            "phase": AttackPhase.DISCOVERY,
            "technique": "T1082 - System Information Discovery",
            "command": "whatweb http://{target}",
            "expected": "",
            "alternatives": ["curl -s http://{target} | grep -i 'powered by'"]
        },
        {
            "name": "Directory Bruteforce",
            "phase": AttackPhase.DISCOVERY,
            "technique": "T1083 - File and Directory Discovery",
            "command": "gobuster dir -u http://{target} -w /usr/share/wordlists/dirb/common.txt -q",
            "expected": "Status: 200",
            "alternatives": ["dirb http://{target} /usr/share/wordlists/dirb/common.txt -S"]
        },
        {
            "name": "SQL Injection Test",
            "phase": AttackPhase.INITIAL_ACCESS,
            "technique": "T1190 - Exploit Public-Facing Application",
            "command": "sqlmap -u 'http://{target}/?id=1' --batch --level=1 --risk=1",
            "expected": "is vulnerable",
            "alternatives": []
        },
    ],
    
    # Template per Privilege Escalation Linux
    "linux_privesc": [
        {
            "name": "SUDO Check",
            "phase": AttackPhase.PRIVILEGE_ESCALATION,
            "technique": "T1548 - Abuse Elevation Control",
            "command": "sudo -l",
            "expected": "may run",
            "alternatives": []
        },
        {
            "name": "SUID Binaries",
            "phase": AttackPhase.PRIVILEGE_ESCALATION,
            "technique": "T1548.001 - Setuid and Setgid",
            "command": "find / -perm -4000 -type f 2>/dev/null | head -20",
            "expected": "/",
            "alternatives": []
        },
        {
            "name": "Cron Jobs",
            "phase": AttackPhase.DISCOVERY,
            "technique": "T1053.003 - Scheduled Task/Job: Cron",
            "command": "cat /etc/crontab; ls -la /etc/cron.d/",
            "expected": "",
            "alternatives": ["crontab -l 2>/dev/null"]
        },
        {
            "name": "Kernel Version",
            "phase": AttackPhase.DISCOVERY,
            "technique": "T1082 - System Information Discovery",
            "command": "uname -a",
            "expected": "Linux",
            "alternatives": ["cat /etc/*-release"]
        },
    ],
}

# ============================================================================
# CHAIN PLANNER
# ============================================================================

class ExploitChainPlanner:
    """
    Pianifica e orchestra attacchi multi-stage.
    
    Uso:
        planner = ExploitChainPlanner()
        chain = planner.create_chain_from_template("linux_ssh_pentest", "192.168.1.1", "Get root shell")
        
        while True:
            step = chain.get_current_step()
            if not step:
                break
            
            # Esegui step.command
            output = execute(step.command)
            
            if expected in output:
                step.mark_success(output)
            else:
                # Prova alternative
                for alt in step.alternatives:
                    output = execute(alt)
                    if expected in output:
                        step.mark_success(output)
                        break
                else:
                    step.mark_failed("No alternative worked")
            
            if not chain.advance():
                break
    """
    
    def __init__(self):
        self.chains: Dict[str, AttackChain] = {}
        self.footholds: List[Foothold] = []
    
    def create_chain_from_template(
        self,
        template_name: str,
        target: str,
        goal: str
    ) -> AttackChain:
        """
        Crea chain da template predefinito.
        
        Args:
            template_name: Nome del template (es: "linux_ssh_pentest")
            target: IP/hostname target
            goal: Obiettivo finale
        """
        if template_name not in ATTACK_TEMPLATES:
            raise ValueError(f"Unknown template: {template_name}")
        
        chain_id = f"chain_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        template = ATTACK_TEMPLATES[template_name]
        
        steps = []
        for i, step_def in enumerate(template):
            step = AttackStep(
                id=f"step_{i:02d}",
                name=step_def["name"],
                phase=step_def["phase"],
                technique=step_def["technique"],
                command=step_def["command"].format(target=target),
                expected_output=step_def["expected"],
                alternatives=[alt.format(target=target) for alt in step_def.get("alternatives", [])]
            )
            steps.append(step)
        
        chain = AttackChain(
            chain_id=chain_id,
            name=f"{template_name} on {target}",
            target=target,
            goal=goal,
            steps=steps
        )
        
        self.chains[chain_id] = chain
        logger.info(f"[ChainPlanner] Chain created: {chain_id} with {len(steps)} steps")
        
        return chain
    
    def create_custom_chain(
        self,
        name: str,
        target: str,
        goal: str,
        steps: List[Dict]
    ) -> AttackChain:
        """
        Crea chain personalizzata.
        
        Args:
            name: Nome della chain
            target: Target
            goal: Obiettivo
            steps: Lista di dict con {name, phase, technique, command, expected}
        """
        chain_id = f"chain_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        attack_steps = []
        for i, s in enumerate(steps):
            step = AttackStep(
                id=f"step_{i:02d}",
                name=s["name"],
                phase=AttackPhase[s.get("phase", "EXECUTION").upper()],
                technique=s.get("technique", "Custom"),
                command=s["command"],
                expected_output=s.get("expected", ""),
                alternatives=s.get("alternatives", [])
            )
            attack_steps.append(step)
        
        chain = AttackChain(
            chain_id=chain_id,
            name=name,
            target=target,
            goal=goal,
            steps=attack_steps
        )
        
        self.chains[chain_id] = chain
        return chain
    
    def add_foothold(
        self,
        host: str,
        access_type: str,
        access_level: str,
        credentials: Dict[str, str] = None
    ) -> Foothold:
        """Registra un nuovo foothold ottenuto"""
        foothold = Foothold(
            host=host,
            access_type=access_type,
            access_level=access_level,
            credentials=credentials or {},
            pivot_possible=True
        )
        self.footholds.append(foothold)
        logger.info(f"[ChainPlanner] Foothold added: {host} ({access_level})")
        return foothold
    
    def suggest_next_chain(self, current_position: str = None) -> Optional[str]:
        """
        Suggerisce la prossima chain da eseguire.
        
        Args:
            current_position: Host attuale (per pivot suggestions)
        """
        # Se abbiamo footholds, suggerisci privesc
        for fh in self.footholds:
            if fh.access_level == "user":
                return "linux_privesc"
        
        # Default: recon
        return "linux_ssh_pentest"
    
    def get_chain_status(self, chain_id: str) -> str:
        """Genera status report per una chain"""
        chain = self.chains.get(chain_id)
        if not chain:
            return "Chain not found"
        
        completed, total = chain.get_progress()
        lines = [
            f"## Chain: {chain.name}",
            f"Progress: {completed}/{total} steps",
            f"Goal: {chain.goal}",
            "",
            "### Steps:"
        ]
        
        for step in chain.steps:
            status_emoji = {
                StepStatus.PENDING: "âšª",
                StepStatus.RUNNING: "ðŸ”µ",
                StepStatus.SUCCESS: "âœ…",
                StepStatus.FAILED: "âŒ",
                StepStatus.SKIPPED: "â­ï¸",
                StepStatus.BLOCKED: "ðŸš«"
            }.get(step.status, "â“")
            
            lines.append(f"- {status_emoji} **{step.name}** [{step.phase.value[0]}]")
            if step.status == StepStatus.SUCCESS and step.output:
                lines.append(f"  Output: `{step.output[:50]}...`")
            elif step.status == StepStatus.FAILED and step.error:
                lines.append(f"  Error: {step.error[:50]}")
        
        return "\n".join(lines)
    
    def adapt_chain_on_failure(
        self,
        chain: AttackChain,
        failed_step_id: str,
        failure_reason: str
    ) -> List[AttackStep]:
        """
        Adatta la chain dopo un fallimento.
        Suggerisce step alternativi o bypass.
        
        Returns:
            Lista di step alternativi suggeriti
        """
        alternatives = []
        
        failed_step = next((s for s in chain.steps if s.id == failed_step_id), None)
        if not failed_step:
            return alternatives
        
        # Se ha alternative non provate
        if failed_step.alternatives:
            for i, alt_cmd in enumerate(failed_step.alternatives):
                alt_step = AttackStep(
                    id=f"{failed_step_id}_alt{i}",
                    name=f"{failed_step.name} (Alt {i+1})",
                    phase=failed_step.phase,
                    technique=failed_step.technique,
                    command=alt_cmd,
                    expected_output=failed_step.expected_output
                )
                alternatives.append(alt_step)
        
        # Suggerimenti generici basati sul tipo di fallimento
        if "connection refused" in failure_reason.lower():
            # Suggerisci port scan piÃ¹ ampio
            alternatives.append(AttackStep(
                id=f"{failed_step_id}_portscan",
                name="Alternative Port Scan",
                phase=AttackPhase.RECONNAISSANCE,
                technique="T1046",
                command=f"nmap -p- --min-rate=1000 {chain.target}",
                expected_output="open"
            ))
        
        if "access denied" in failure_reason.lower():
            # Suggerisci altri vettori
            alternatives.append(AttackStep(
                id=f"{failed_step_id}_enum",
                name="Additional Enumeration",
                phase=AttackPhase.DISCOVERY,
                technique="T1083",
                command=f"enum4linux -a {chain.target}",
                expected_output=""
            ))
        
        return alternatives

# ============================================================================
# SINGLETON
# ============================================================================

_planner_instance: Optional[ExploitChainPlanner] = None

def get_chain_planner() -> ExploitChainPlanner:
    """Restituisce istanza singleton"""
    global _planner_instance
    if _planner_instance is None:
        _planner_instance = ExploitChainPlanner()
    return _planner_instance
